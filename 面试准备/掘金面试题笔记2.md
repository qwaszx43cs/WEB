地址： https://yuchengkai.cn/

## 内置类型

七种内置类型，又分为基本类型和引用类型

## Typeof

typeof是一个一元运算符，返回一个字符串类型。typeof能准确判断基本数据类型，typeof不能准确判断null和引用数据类型,除了函数都返回"object"

```javascript

    console.log(typeof []); //object
    console.log(typeof {}); //object
    console.log(typeof null); // object
    console.log(typeof function(){}); // function

```

### typeof null 为什么返回"object"

null的底层储存二进制为000，000开头的代表对象

### 准确返回对象的类型

`Object.prototype.toString.call()`会返回[Object Type]的字符串

```javascript

  Object.prototype.toString.call([]);  // "[object Array]"
  Object.prototype.toString.call(function(){}); // "[object Function]"

```


## 类型转换

显示转换

### 转Boolean

除了`空字符串`,`false`, `NaN`, `0`, `-0`, `null`, `undefined`,其他值都转为true

### 其他类型转化为字符串

(1) number -> 直接转换为字符串

(2) boolean -> "true", "false"

(3) null -> "null"

(4) undefined -> "undefined"

(5) object -> "[object Object]"

### 其他类型转Number

(1) 字符串 -> 空字符串 - 0 ,数字字符串转为数字，非数字字符串转为NaN

(2) boolean -> true - 1, false - 0

(3) null -> 0

(4) undefined -> NaN

(5) Array -> 空数组 - 0, 单个数字成员 - 数字，其他为NaN

(6) 对象 ->  NaN

### 对象转基本类型

先调用`valueOf`方法，再调用`toString`


### 四则运算符

隐式类型转换

#### 加法

运算子不同会导致加法的重载

只有当一个运算子为字符串时，另一个也会转为字符串

**注意** `'a' + + 'b'; // aNaN` ，因为+ 'b'为NaN

#### 其他运算

其他运算中，运算子一律转换为数字进行运算


### 比较运算符

`==`非严格等于，先对比较的数据做类型转换，再比较值

`===`严格等于，先比较两者类型，不相同返回false, 若相同再比较值


### 原型

1. 每个函数都有`prototype`属性，除了`Function.prototype.bind()`, 该属性指向原型；

2. 每个对象都有`__proto__`属性，指向创建该对象的构造函数的原型。其实这个属性指向了`[[prototype]]`,但是它是内部属性无法访问，所以使用`__proto__`来访问

3. 对象可以通过__proto__来寻找原型中的属性，__proto__将对象连接起来组成了原型链


### instanceof 

`instanceof`用来判断数据类型，A instanceof B 在A的原型链中是否有B构造函数的原型(prototype)

手写实现instanceof

```javascript

  function _instanceof(a, b) {
    while(true) {
      if (a.__proto__ == null) {
        return false;
      } 
      if (a.__proto__ == b.prototype) {
        return true;
      }
      a.__proto__ = a.__proto__.__proto__;
    }
  }

```

### this 

  其他的比较熟悉了，再巩固下箭头函数

  箭头函数本身没有this指向，取决于它**外面的第一个不是箭头函数的函数的this**


### 执行上下文

参考文章: https://www.jianshu.com/p/6f8556b10379

执行JS代码时，会产生三种执行上下文

1) 全局执行上下文

2) 函数（局部）执行上下文

3）eval执行上下文

每个执行的上下文都有三个重要的属性: 

1) 变量对象(VO),包括变量，函数声明和函数形参，该属性只能在全局上下文访问

2) 作用域链

3) this


### 闭包

通俗来说，函数A返回一个函数B，在函数B中使用了A的变量。函数B就称之为闭包

```javascript
function fn() {
  let a = 1; 
  return function() {
    let b = a;
    console.log(b);
  }
}

```