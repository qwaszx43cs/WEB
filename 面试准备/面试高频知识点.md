### 1. JS内置数据类型


### 2. typeof

1. typeof 和 instanceof 区别

- typeof是一元运算符，返回数据类型的字符串。对基本类型能准确判断，引用类型(null, Object)除了函数类型返回`'function'`以外，都返回`Object`

typeof 对于未声明和声明后未初始化的变量都返回`'undefined'` 

准确返回对象数据类型`Object.prototype.toString.call()`, 返回`[object ObjectType]`字符串

- A instanceof B用来检查A的原型链中是否有B构造函数的原型

手写一个instanceof方法

```javascript

  /*
    param a 要判断的对象
    param b 构造函数
  */    
  function _instanceof(a, b) {
    while (a.__proto__ == null) {
      if (a.__proto__ == null) {
        return false;
      }
      if (a.__proto__ == b.prototype) {
        return true;
      } 
      a.__proto__ = a.__proto__.__proto__;
    }
  }

  console.log([] instanceof Array); // true

```


### 3. Array

1. 类数组转换为数组

```javascript

Array.prototype.slice.call(null, arguments);
Array.from(arguments); // ES6

```
2. 扁平化多维数组

`Array.flat(depth)`

3. 数组去重

  - set数据类型 + Array.from()

  set是ES6新出的数据结构，它类似于数组，没有重复的成员；

  Array.from()将两类对象转化为数组，类数组和可遍历的对象

  ```javascript
  
    let arr = [1, 2, 'sky', 'sky', 20 ,9 , 9, 1];

    let arr1 = Array.from(new Set(arr));
    
    console.log(arr1); // [ 1, 2, "sky", 20, 9 ]
  
  ```

4. 数组排序

  - `sort()`: 无参数时按照Unicode排序，从小到大

  ```javascript
  
    let arr = [1, 2, 20 ,9 , 9, 1];

    result = arr.sort((a, b) => a - b); // 从小到大
    result = arr.sort((a, b) => b - a); // 从大到小
    console.log(result); // [ 1, 1, 2, 9, 9, 20 ]

  ```

  - 冒泡排序

  左右两个成员比较大小，大的放右边

  ```javascript
  
    let arr = [1, 2, 20 ,99 , 9, 1, 31];

    function bubbleSort(arr) {
      let length = arr.length;
      for (let i = 0; i < length - 1; i++) {
        for (let j = 0; j < length - 1 - i; j ++) {
          if (arr[j] > arr[j + 1]) {
            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
          }
        }
      }
      return arr;
    }

  
  ```

  - 选择排序

  从第一个位置开始比较，找出最小的和第一个换位置，再到下一轮

  ```javascript
  
    let arr = [1, 2, 20 ,99 , 9, 1, 31];

    function selectSort(arr) {
      let length = arr.length;
      for (let i = 0; i < length - 1; i++) {
        for (let j = i + 1; j < length; j ++) {
          if (arr[i] > arr[j]) {
            [arr[i], arr[j]] = [arr[j], arr[i]];
          }
        }
      }
      return arr;
    }

    console.log(selectSort(arr));

  
  ```

5. 求数组最大值

  - Math.max()与apply()方法结合

  ```javascript

    let arr = [1, 2, 20 ,99 , 9, 1, 31];

    let max = Math.max.apply(null, arr);
    console.log(max); // 99

  ```
  
  - reduce()方法

  ```javascript
  
    let arr = [1, 2, 20 ,99 , 9, 1, 31];

    let max = arr.reduce((a, b) => {
      return Math.max(a, b);
    });

    console.log(max); // 99
  
  ```

6. 数组求和

- Array.reduce()

```javascript

    let arr = [1, 2, 20 ,99 , 9, 1, 31];
    let result = arr.reduce((a, b) => {
      return a + b;
    });

    console.log(result); // 163

```

7. 数组合并

- Array.concat()

- Array.prototype.push.apply()

### 4. Number 

1. 0.1 + 0.2 === 0.3 为什么是false

0.1 和 0.2 的二进制表示不精确，加起来的值不是精确的0.3

2. 上述问题解决方法

将错误舍入做一个小的容差

```javascript

  function numberComparison(a, b) {
    return Math.abs(a - b) < Number.EPSILON;
  }

  console.log(numberComparison(0.1 + 0.2, 0.3));


```

### 5. 类型转换（强制类型转换&隐式转换）

### 6. 作用域

### 7. 闭包