## 作用域scope

**概念**: 作用域是函数或变量的作用范围

**目的**: 提高程序可靠性，减少命名冲突

### 作用域的分类

ES6之前，JS作用域分为全局作用域和局部作用域

- 全局作用域: 作用于script标签中或整个JS文件

- 局部作用域: 作用于函数中

### 访问关系

在局部作用域可以访问全局作用域变量，全局作用域不能访问局部作用域变量。

### 变量的作用域

变量根据作用域不同可以分为全局变量和局部变量

**全局变量**

- 在全局作用域中声明的变量为全局变量，整个JS都能访问该变量

- 特殊情况: 在函数中，不使用var声明的变量为全局变量。（不推荐使用）

```javascript
  function f() {
    a = 1;
    var b = 1;
  }

  f();
  console.log(a);
  console.log(b); // b is not defined;
```

**局部作用域**

- 定义在函数内的变量为局部变量

- 函数的形参也是局部变量

### 作用域的上下级关系

在函数中操作一个变量，会优先在该作用域中寻找该变量(**就近原则**),若有则使用，若没有则到上一级作用域寻找；如果没有，则报referenceError

在全局作用域中有一个全局对象window,所有变量都会以window对象的属性储存，所有函数都为window对象的方法。

## 变量提升

使用**var关键字声明的变量**，会在代码执行前被声明

代码示例1:

```javascript
  console.log(a); // undefined
  var a = 1;
```

代码示例2:

```javascript
    console.log(a); // ReferenceError: a is not defined;
    a = 1;
```

代码示例3：

```javascript
    foo(); // undefined

    function foo() {
      if (false) {
        var i = 123;
      }
      console.log(i);
    }
```

var声明的i变量在函数执行前就被提前声明了，即使foo函数中的`if (false)`中的代码不会被执行，但代码有**解析**环节，解析时已经把变量i提前声明了


## 函数提升

使用`函数声明`创建的函数会被**声明提前**，也就是说函数在被使用之前就已经创建完成。

```javascript
  foo();
  function foo() {
    console.log(1);
  }
```

使用`函数表达式`创建的函数不会被声明提前，所以不能在声明前调用。

```javascript
  foo(); // undefined
  var foo = function(){
    console.log(1);
  };
```

返回undefined是因为变量foo被提升了

## 函数作用域

**注意项1:** 在函数作用域中，也有变量提升的现象。

- 在函数中，var声明的变量，会在函数所有代码被执行前被声明

- 在函数中，没有var声明的变量都是**全局变量**，而且不会提前声明

**注意项2：** 定义形参相当于在函数作用域中声明了变量。


**作用域链:** 内部函数访问外部函数变量，采用的是链式方法逐级向外访问，查找时遵循就近原则。
